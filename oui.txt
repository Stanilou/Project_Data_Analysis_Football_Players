2 Analyse Factorielle des Correspondance
Afin de réaliser l’analyse factorielle des correspondance vous commencerez par réaliser un tableau de contingence entre les deux variables que vous souhaitez analyser. Pour ce faire vous pouvez utiliser la fonction ’crosstab’ de la librairie panda. Voici un exemple :
data_crosstab = pd.crosstab(data_quantitative["Age"], data_quantitative["Gls"])
Une fois cette étape réalisée vous procéderez à la standardisation des données
(cf. TD 01 Analyse ACP).
temp = data_crosstab.sub(data_crosstab.mean())
data_scaled = temp.div(data_crosstab.std())
Nous allons maintenant nous assurer qu’il est pertinent de réaliser une AFC
sur ces données. Pour ce faire nous faisons le test suivant :test de sphéricité de
Bartlett (Bartlett Sphericity Test en anglais). Ce test vérifie les intercorrelations
entre les variables en faisant la comparaison entre la matrice de corrélation et la
matrice identité. Si les variables sont indépendantes, la matrice de corrélation
est égale à la matrice identité.
Afin de pouvoir réaliser une AFC, il est nécessaire que les variables soient
globalement dépendantes, ie. que la matrice de corrélation et la matrice d’identité
ne soient pas les mˆemes. Il faut pour cela que la p-value du test de sphéricité
de Bartlett soit le plus proche possible de 0.

from factor_analyzer.factor_analyzer import calculate_bartlett_sphericity
chi_square_value,p_value=calculate_bartlett_sphericity(data_scaled)
print(p-value)

A partir du moment o`u vos données sont valides pour une AFC, vous pouvez
maintenant déterminer le nombre de facteurs à conserver pour votre analyse.
Les facteurs, les variables latentes, sont des combinaisons linéaires des points
modalités (lignes ou colonnes) exprimés par des profils (lignes ou colonnes). Le
nombre maximal de facteurs est égal au minimum du nombre de lignes et de
colonnes -1 :
n_factorsmax = min(col − 1, li − 1)
Nous commencerons par réaliser une première analyse sans rotation afin de
déterminer le nombre de facteurs à fixer pour l’analyse.
fa = FactorAnalyzer(n_factors = 6, rotation=None)
fa.fit(data_scaled)
ev, v = fa.get_eigenvalues()
print(ev)
Nous afficherons les résultats grˆace à un graphique.

plt.scatter(range (1, data_scaled. shape [1]+1), ev)
plt.plot(range (1, data_scaled.shape [1]+1), ev)
plt.title('Scree Plot')
plt.xlabel('Factors')
plt.ylabel('Eigenvalue')
plt.grid()
plt.show()

Seuls les facteurs avec une valeur propre supérieur ou égale à 1 seront gardés.
Nous pouvons finalement réaliser l’AFC avec le nombre de facteurs appropriés. Le code ci-dessous permet d’afficher les AFC en fonctions de 3 rotations
différentes, les représentation graphiques seront donc légérement différentes.
(FA pour Factorial Analisys).

methods = [
    ("FA No rotation", FactorAnalysis(2,)),
    ("FA Varimax", FactorAnalysis(2, rotation="varimax")),
    ("FA Quartimax", FactorAnalysis(2, rotation="quartimax")),
]

fig, axes = plt.subplots(ncols=3, figsize=(10, 8), sharex=True, sharey=True)

for ax, (method, fa) in zip(axes, methods):
    fa = fa.fit(data_scaled)

    components = fa.components

    vmax = np.abs(components).max()
    ax.scatter (components [0,:], components [1, :])
    ax.axhline (0, -1, 1, color='k')
    ax.axvline (0, -1, 1, color='k')
    for i,j,z in zip (components [0,], components [1, :], data_scaled.columns):
        ax.text (i+.02, j+.02, str(z), ha="center")
    for i,j,z in zip (components [0,], components [1, :], data_scaled.index):
        ax.text (i+.02, j+.02, str (z), ha="center")
    ax.set_title (str(method))
    if ax.get_subplotspec(). is_first_col ():
        ax.set_ylabel("Factor 1")
    ax.set_xlabel("Factor 2")

plt.tight_layout ()
plt.show()


temp = data_crosstab.sub(data_crosstab.mean())
data_scaled = temp.div(data_crosstab.std())

chi_square_value, p_value = calculate_bartlett_sphericity(data_scaled)
print("P_value : ", p_value)

fa = FactorAnalyzer(n_factors = 6, rotation=None)
fa.fit(data_scaled)
ev, v = fa.get_eigenvalues()
print("Ev :", ev)

plt.scatter(range (1, data_scaled. shape [1]+1), ev)
plt.plot(range (1, data_scaled.shape [1]+1), ev)
plt.title('Scree Plot')
plt.xlabel('Factors')
plt.ylabel('Eigenvalue')
plt.grid()
plt.show()

methods = [
    ("FA No rotation", FactorAnalysis(2,)),
    ("FA Varimax", FactorAnalysis(2, rotation="varimax")),
    ("FA Quartimax", FactorAnalysis(2, rotation="quartimax")),
]

fig, axes = plt.subplots(ncols=3, figsize=(10, 8), sharex=True, sharey=True)

for ax, (method, fa) in zip(axes, methods):
    fa = fa.fit(data_scaled)

    components = fa.components_

    vmax = np.abs(components).max()
    ax.scatter (components [0,:], components [1, :])
    ax.axhline (0, -1, 1, color='k')
    ax.axvline (0, -1, 1, color='k')
    for i,j,z in zip (components [0,], components [1, :], data_scaled.columns):
        ax.text (i+.02, j+.02, str(z), ha="center")
    for i,j,z in zip (components [0,], components [1, :], data_scaled.index):
        ax.text (i+.02, j+.02, str (z), ha="center")
    ax.set_title (str(method))
    if ax.get_subplotspec(). is_first_col ():
        ax.set_ylabel("Factor 1")
    ax.set_xlabel("Factor 2")

plt.tight_layout ()
plt.show()